#!/usr/bin/env python
# encoding: utf-8
"""
Models for singlepix emcee-based SED MCMC.
"""

import numpy as np
import fsps

from sedbot.photconv import abs_ab_mag_to_mjy
from sedbot.zinterp import bracket_logz, interp_logz


class ThreeParamSFHFixedD(object):
    """Model for tau+const+t0 SFH, single Z, and two component dust with
    fixed distance.

    Parameters
    ----------
    sed : ndarray
        SED in µJy, shape ``(nbands,)``.
    err : ndarray
        SED uncertainties in µJy, shape ``(nbands,)``.
    area : float
        Area of SED's pixel in arcsec^2.
    d : float
        Distance to object, in parsecs.
    priors : dict
        Dictionary of parameter name, prior function.
    pixel_metadata : ndarray
        Arbitrary structured array with metadata about the pixels. This
        will be appended to the chain metadata under the `'pixels'` field.
    sed_bands : list
        List of bandpass names corresponding to the ``seds``
    compute_bands : list
        List of bandpasses to compute and included in the chain metadata.
    pset : dict
        Initialization arguments to :class:`fsps.StellarPopulation`, as a
        dictionary.
    """
    _param_names = ('logmass', 'logZZsol', 'sf_start', 'logtau', 'const',
                    'dust1', 'dust2')

    def __init__(self, sed, sed_err, sed_bands, area, d, priors,
                 pixel_metadata=None,
                 compute_bands=None,
                 pset=None):
        super(ThreeParamSFHFixedD, self).__init__()
        self._sed = sed
        self._err = sed_err
        self._area = area
        self.pixel_metadata = pixel_metadata
        self._obs_bands = sed_bands
        self._d = d
        self._priors = priors
        if compute_bands is None:
            self._compute_bands = self._obs_bands
        else:
            self._compute_bands = compute_bands
            # Ensure compute bands is a superset of observed SED
            assert set(self._compute_bands) >= set(self._obs_bands)
        if pset is None:
            pset = {}
        self.sp = fsps.StellarPopulation(**pset)

    @property
    def band_indices(self):
        return np.array([self._compute_bands.index(b)
                         for b in self._obs_bands])

    @property
    def computed_bands(self):
        """Names of bandpasses in the `'model_sed'` metadata. This can be a
        superset of :attr:``observed_bands``.
        """
        return self._compute_bands

    @property
    def observed_bands(self):
        """Names of bandpasses in the *observed* SED."""
        return self._obs_bands

    @property
    def n_bands(self):
        return self._seds.shape[0]

    @property
    def n_computed_bands(self):
        return len(self._compute_bands)

    @property
    def n_params(self):
        """Number of theta parameters."""
        return len(self._param_names)

    @property
    def param_names(self):
        """Ordered list of theta-level parameter names."""
        return self._param_names

    @property
    def priors(self):
        return self._priors

    @property
    def blob_dtype(self):
        """Dtype for the blob data generated by this model for each pixel."""
        dt = [('logMstar', np.float),
              ('logMdust', np.float),
              ('logLbol', np.float),
              ('logSFR', np.float),
              ('logAge', np.float),
              ('model_sed', np.float, self.n_computed_bands)]
        return np.dtype(dt)

    def __call__(self, theta):
        """Posterior likelihood call."""
        # Evaluate prior
        lnprior = np.sum(np.array([self._priors[n](v)
                                   for n, v in zip(self._param_names, theta)]))
        if ~np.isfinite(lnprior):
            return -np.inf, None

        meta1 = np.empty(5, dtype=float)
        meta2 = np.empty(5, dtype=float)

        for name, val in zip(self._param_names, theta):
            if name == 'logmass':
                logm = val
            elif name == 'logZZsol':
                logZZsol = val
            elif name == 'logtau':
                self.sp.params['tau'] = 10. ** val
            elif name in self.sp.params.all_params:  # list of parameter names
                self.sp.params[name] = val

        zmet1, zmet2 = bracket_logz(logZZsol)
        # Compute fluxes with low metallicity
        self.sp.params['zmet'] = zmet1
        f1 = abs_ab_mag_to_mjy(
            self.sp.get_mags(tage=13.8, bands=self._compute_bands),
            self._d)
        meta1[0] = self.sp.stellar_mass
        meta1[1] = self.sp.dust_mass
        meta1[2] = self.sp.log_lbol
        meta1[3] = self.sp.sfr
        meta1[4] = self.sp.log_age
        # Compute fluxes with high metallicity
        self.sp.params['zmet'] = zmet2
        f2 = abs_ab_mag_to_mjy(
            self.sp.get_mags(tage=13.8, bands=self._compute_bands),
            self._d)
        meta2[0] = self.sp.stellar_mass
        meta2[1] = self.sp.dust_mass
        meta2[2] = self.sp.log_lbol
        meta2[3] = self.sp.sfr
        meta2[4] = self.sp.log_age

        # Interpolate and scale the SED by mass
        model_mjy = 10. ** logm * interp_logz(zmet1, zmet2, logZZsol, f1, f2)

        # Interpolate metadata between the two metallicities
        meta = interp_logz(zmet1, zmet2, logZZsol, meta1, meta2)

        # Compute likelihood
        # Automatically ignores pixels with no measurement (Nan)
        lnL = -0.5 * np.nansum(
            np.power((model_mjy[self.band_indices] * self._area
                      - self._sed) / self._err, 2.))
        lnpost = lnprior + lnL
        if ~np.isfinite(lnpost):
            lnpost = -np.inf

        # Scale statistics by the total mass
        blob = {"logMstar": logm + np.log10(meta[0]),  # log solar masses,
                "logMdust": logm + np.log10(meta[1]),  # log solar masses
                "logLbol": logm * meta[2],  # log solar luminosities
                "logSFR": logm * meta[3],  # star formation rate, M_sun / yr
                "logAge": meta[4],
                "model_sed": model_mjy}

        return lnpost, blob
