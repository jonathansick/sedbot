#!/usr/bin/env python
# encoding: utf-8
"""
Data structure and persistence for emcee chains with HDF5.
"""

import numpy as np
from astropy.table import Table, vstack, hstack
import h5py


class SinglePixelChain(Table):
    """Table for single-pixel-class samplers (ie, ``sedbot.singlepixel``)."""
    def __add__(self, other_table):
        """Concatenate tables.

        e.g. tbl = tbl1 + tbl2

        Note this is a left-add, so `tbl1` in the example gets called.
        """
        other_table.meta = {}
        # Throw out last value of this table because it's probably going
        # to be the first value of the next one
        return MultiPixelChain(vstack((self[:-1], other_table),
                                      metadata_conflicts='silent',
                                      join_type='exact'))

    @property
    def sed_residuals_chain(self):
        """Chain of :math:`F_\mathrm{obs} - F_\mathrm{model}` SED residuals
        for a single pixel.

        Parameters
        ----------
        ipix : int
            Pixel ID.
        add_background : bool
            If ``True`` then the background is added to the modelled SED.

        Returns
        -------
        residuals : ndarray
            A ``(n_sample, n_band)`` numpy array. The order of bandpasses
            corresponds to ``self.meta['computed_bands']``.
        """
        idx = self.meta['band_indices']
        model = self['model_sed'][:, idx]
        obs = self.meta['sed']
        return obs - model

    @property
    def sed_ratios_chain(self):
        """Chain of :math:`F_\mathrm{obs} / F_\mathrm{model}` SED ratios
        for a single pixel.

        Returns
        -------
        ratios : ndarray
            A ``(n_sample, n_band)`` numpy array. The order of bandpasses
            corresponds to ``self.meta['computed_bands']``.
        """
        idx = self.meta['band_indices']
        model = self['model_sed'][:, idx]
        obs = self.meta['sed']
        return obs / model


class MultiPixelChain(Table):
    """Table for the MCMC chain generated by a ``sedbot.multipixel``
    Gibbs sampler.
    """

    @classmethod
    def join_single_pixel_chains(cls, tables):
        """Join a list of :class:`SinglePixelChain` instances, creating a
        :class:`MultiPixelChain`.

        Parameters
        ----------
        tables : list
            List of :class:`SinglePixelChain` instances. The order defines
            the order of the pixels in the combined chain.

        Returns
        -------
        chain : :class:`MultiPixelChain` instance
            The :class:`MultiPixelChain` with single pixel chains
            combined.
        """
        chain_colnames = tables[0].colnames
        n_chains = len(tables)
        n_sed_bands = len(tables[0].meta['computed_bands'])
        n_params = len(tables[0].meta['theta_params'])
        n_steps = len(tables[0])

        # Copy chain data
        dt = [(n, np.float, n_chains) for n in chain_colnames
              if n not in ['model_sed', 'lnpriors']] \
            + [('model_sed', np.float, (n_chains, n_sed_bands))] \
            + [('lnpriors', np.float, (n_chains, n_params))]
        data = np.empty(n_steps, dtype=np.dtype(dt))
        data.fill(np.nan)
        for i, tbl in enumerate(tables):
            for colname in chain_colnames:
                if colname == 'model_sed':
                    data['model_sed'][:, i, :] = tbl['model_sed']
                elif colname == 'lnpriors':
                    data['lnpriors'][:, i, :] = tbl['lnpriors']
                else:
                    data[colname][:, i] = tbl[colname]

        # Copy metadata
        meta = {}
        # Copy scalar constant quantites for all pixels
        copy_keys = ['d', 'observed_bands', 'instruments',
                     'computed_bands', 'msun_ab',
                     'band_indices', 'theta_params', 'n_walkers']
        for k in copy_keys:
            meta[k] = tables[0].meta[k]
        # Array metadata
        meta['sed'] = np.array([t.meta['sed'] for t in tables])
        meta['sed_err'] = np.array([t.meta['sed_err'] for t in tables])
        meta['area'] = np.array([t.meta['area'] for t in tables])
        meta['pixels'] = np.concatenate([t.meta['pixels'] for t in tables])
        meta['acor'] = np.concatenate([t.meta['acor'] for t in tables])
        meta['f_accept'] = np.concatenate([t.meta['f_accept'] for t in tables])

        tbl = cls(data, meta=meta)
        return tbl

    def __add__(self, other_table):
        """Concatenate tables.

        e.g. tbl = tbl1 + tbl2

        Note this is a left-add, so `tbl1` in the example gets called.
        """
        other_table.meta = {}
        # Throw out last value of this table because it's probably going
        # to be the first value of the next one
        return MultiPixelChain(vstack((self[:-1], other_table),
                                      metadata_conflicts='silent',
                                      join_type='exact'))

    @property
    def n_pixels(self):
        return self['model_sed'].shape[1]

    def chain_for_pixel(self, ipix, use_cols=None):
        """Return the chain for a single pixel as a structured array.

        Parameters
        ----------
        ipix : int
            Pixel ID.
        use_cols : list
            Names of columns to include in output, or ``None`` to include all.

        Returns
        -------
        chain : ndarray
            A structured numpy array.
        """
        if use_cols is None:
            colnames = list(self.dtype.names)
        else:
            colnames = list(use_cols)

        # NOTE temporarily forcing removal of sed_model from chain output
        if 'model_sed' in colnames:
            colnames.remove('model_sed')

        dtype = [(n, np.float) for n in colnames]
        arr = np.empty(len(self), dtype=np.dtype(dtype))
        single_value_fields = list(self.meta['phi_params']) \
            + ["B__{0}__{1}".format(n, b)
               for n, b in zip(self.meta['instruments'],
                               self.meta['observed_bands'])]
        for i, n in enumerate(colnames):
            if n in single_value_fields:
                # single value for all pixels
                arr[n] = self[n]
            else:
                arr[:][n] = self[n][:, ipix]
        return arr

    def chain_array_for_pixel(self, ipix,
                              use_cols=None,
                              return_colnames=False):
        """Same as :meth:`chain_for_pixel`, except the returned array is
        2D

        Parameters
        ----------
        ipix : int
            Pixel ID.
        use_cols : list
            Names of columns to include in output, or ``None`` to include all.
        return_colnames : bool
            If ``True``, then a list of column names will be provided.

        Returns
        -------
        chain : ndarray
            A ``(n_sample, n_param)`` numpy array.
        colnames : list
            List of column names, if ``return_colnames == True``.
        """
        chain_tbl = self.chain_for_pixel(ipix, use_cols=use_cols)
        colnames = chain_tbl.dtype.names
        chain = chain_tbl.view(np.float).reshape(chain_tbl.shape + (-1,))
        # Expand columns as necessary
        # e.g. the sed_model array should be converted into a flat array
        if return_colnames:
            return chain, colnames
        else:
            return chain

    def sed_chain_for_pixel(self, ipix):
        """Provides a chain array for the modelled SED of a single pixel.

        .. note:: The modelled background *is not added* because the modelled
           SED may be a superset of the observed SED.

        Parameters
        ----------
        ipix : int
            Pixel ID.

        Returns
        -------
        chain : ndarray
            A ``(n_sample, n_band)`` numpy array. The order of bandpasses
            corresponds to ``self.meta['computed_bands']``.
        """
        arr = self['model_sed'][:, ipix, :]
        return arr

    def sed_residuals_chain_for_pixel(self, ipix, add_background=True):
        """Chain of :math:`F_\mathrm{obs} - F_\mathrm{model}` SED residuals
        for a single pixel.

        Parameters
        ----------
        ipix : int
            Pixel ID.
        add_background : bool
            If ``True`` then the background is added to the modelled SED.

        Returns
        -------
        residuals : ndarray
            A ``(n_sample, n_band)`` numpy array. The order of bandpasses
            corresponds to ``self.meta['computed_bands']``.
        """
        idx = self.meta['band_indices']
        model = self['model_sed'][:, ipix, idx]
        if add_background:
            model += self.background_array * self.meta['area'][ipix]
        obs = self.meta['sed'][ipix, :]
        return obs - model

    def sed_ratios_chain_for_pixel(self, ipix, add_background=True):
        """Chain of :math:`F_\mathrm{obs} - F_\mathrm{model}`
        SED ratios for a single pixel.

        Parameters
        ----------
        ipix : int
            Pixel ID.
        add_background : bool
            If ``True`` then the background is added to the modelled SED.

        Returns
        -------
        ratios : ndarray
            A ``(n_sample, n_band)`` numpy array. The order of bandpasses
            corresponds to ``self.meta['computed_bands']``.
        """
        idx = self.meta['band_indices']
        model = self['model_sed'][:, ipix, idx]
        if add_background:
            model += self.background_array * self.meta['area'][ipix]
        obs = self.meta['sed'][ipix, :]
        return obs / model

    @property
    def background_array(self):
        """A ``(n_sample, n_band)`` ndarray of background samples."""
        fields = ["B_{0}".format(n) for n in self.meta['observed_bands']]
        B = np.empty((len(self), len(fields)), dtype=np.float)
        for i, f in enumerate(fields):
            B[:, i] = self[f]
        return B


class MultiPixelDataset(object):
    """Representation of multiple SinglePixelChains in a multi-table HDF5
    file, as well as parameter estimate tables.

    This class is better suited to handling large ensembles than joining
    SinglePixelChains in a MultiPixelChain.
    """
    def __init__(self, hdf5_path):
        super(MultiPixelDataset, self).__init__()
        self._filepath = hdf5_path

    @classmethod
    def build_dataset_from_chains(cls, hdf5_path, chains, burn=0):
        """Build a dataset from a list of in-memory SinglePixelChain tables.

        This assumes that the list of pixels/chains is complete (the pixel
        ID corrresponds to the index of the pixel in the `chains` list).
        """
        for i, chain in enumerate(chains):
            chain_path = "chains/{0:d}".format(i)
            chain.write(hdf5_path, format='hdf5', path=chain_path,
                        append=True, overwrite=True)
        instance = cls(hdf5_path)
        instance.build_pixels_table()
        instance.build_estimates_table(burn=burn)
        return instance

    @property
    def pixel_ids(self):
        """List of pixel IDs contained in this dataset."""
        try:
            with h5py.File(self._filepath, 'a') as f:
                pixel_ids = [int(k) for k in f['chains'].keys()]
            pixel_ids.sort()
        except KeyError:
            # chain HDF5 group does not exist
            pixel_ids = []
        return pixel_ids

    def add_chain_from_file(self, chain_path, pixel_id):
        chain = SinglePixelChain.read(chain_path, path='chain')
        hdf_path = "chains/{0:d}".format(pixel_id)
        chain.write(self._filepath, format='hdf5', path=hdf_path,
                    append=True, overwrite=True)

    def read_chain(self, pixel_id):
        """Read an individual :class:`SinglePixelChain`."""
        pixel_id = int(pixel_id)
        tbl = SinglePixelChain.read(self._filepath,
                                    path="chains/{0:d}".format(pixel_id))
        return tbl

    @property
    def pixels(self):
        """The pixels table, containing information on each pixel."""
        return Table.read(self._filepath, path='pixels')

    @property
    def estimates(self):
        """The estimates table, containing information on each pixel."""
        return Table.read(self._filepath, path='estimates')

    def build_pixels_table(self, n_pixels=None):
        """Build the ``pixels`` table, which is built from the `'pixels'`
        metadata of individual chains.
        """
        with h5py.File(self._filepath, 'a') as f:
            if 'pixels' in f:
                del f['pixels']
        pixel_ids = self.pixel_ids
        if len(pixel_ids) == 0:
            return
        pixel_ids.sort()

        if n_pixels is None:
            # Hack to ensure pixel grid is at least big enough
            n_pixels = max(pixel_ids) + 1
        assert n_pixels > max(pixel_ids)

        # Get schema for the pixel metadata
        chain0 = self.read_chain(0)
        n_bands = len(chain0.meta['sed'])
        obs_bands = chain0.meta['observed_bands']
        instruments = chain0.meta['instruments']

        pixels_dtype = chain0.meta['pixels'].dtype
        pixel_data = np.empty(n_pixels, dtype=pixels_dtype)
        pixel_data.fill(np.nan)

        sed_data = np.empty(
            n_pixels,
            dtype=np.dtype([('sed', np.float, n_bands),
                            ('sed_err', np.float, n_bands)]))
        sed_data.fill(np.nan)

        for pixel_id in pixel_ids:
            chain = self.read_chain(pixel_id)
            for colname in pixels_dtype.names:
                pixel_data[colname][pixel_id] = chain.meta['pixels'][colname]
            sed_data['sed'][pixel_id] = chain.meta['sed']
            sed_data['sed_err'][pixel_id] = chain.meta['sed_err']
        meta = {"observed_bands": obs_bands,
                "instruments": instruments}
        pixel_table = Table(pixel_data, meta=meta)
        sed_table = Table(sed_data)
        pixel_table = hstack([pixel_table, sed_table], join_type='exact')
        pixel_table.write(self._filepath, path="pixels", format="hdf5",
                          append=True, overwrite=True)

    def build_estimates_table(self, burn=0, n_pixels=None):
        """Estimate the [q25, q50, q75] for all parameters in the chain.

        Table has columns with parameter names. Len n_pixels. Shape (3,) for
        q25, q50, q75.
        """
        with h5py.File(self._filepath, 'a') as f:
            if 'estimates' in f:
                del f['estimates']
        pixel_ids = self.pixel_ids
        if len(pixel_ids) == 0:
            return
        pixel_ids.sort()

        if n_pixels is None:
            # Hack to ensure pixel grid is at least big enough
            n_pixels = max(pixel_ids) + 1
        assert n_pixels > max(pixel_ids)

        chain0 = self.read_chain(0)
        n_bands = len(chain0.meta['computed_bands'])
        param_names = chain0.colnames
        if 'model_sed' in param_names:
            param_names.remove('model_sed')
        dt = [(n, np.float, 3) for n in param_names + ['logMstarMdust']]
        dt += [('model_sed', np.float, (3, n_bands))]
        data = np.empty(n_pixels, dtype=np.dtype(dt))
        for pix_id in pixel_ids:
            chain = self.read_chain(pix_id)[burn:]
            for param in param_names:
                q25_50_75 = np.percentile(chain[param], [25, 50, 75])
                data[param][pix_id] = q25_50_75
            # Parameter Estimates for model SEDs
            for i in xrange(n_bands):
                q25_50_75 = np.percentile(chain['model_sed'][:, i],
                                          [25, 50, 75])
                data['model_sed'][pix_id, :, i] = q25_50_75
            # Also compute star-to-dust mass ratio
            star_dust = chain['logMstar'] - chain['logMdust']
            q25_50_75 = np.percentile(star_dust, [25, 50, 75])
            data['logMstarMdust'][pix_id] = q25_50_75

        meta = {"computed_bands": chain0.meta['computed_bands']}
        tbl = Table(data, meta=meta)
        tbl.write(self._filepath, path='estimates', format='hdf5',
                  overwrite=True, append=True)
